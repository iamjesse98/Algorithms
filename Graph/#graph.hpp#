typedef struct triplet{
    int a[3];
    bool operator<(const struct b &){
        if(a[0]<b[0])
            return true;
        else if(a[0]>b[0])
            return false;
        else{
            if(a[1]<b[1])
		return true;
	    else if(a[1]>b[1])
		return false;
	    else
            return a[2]
		}
    }
}Triplet;

bool Triplet_Comparator(const Triplet & a, const Triplet &b){
    if(a[0]<b[0])
        return true;
    else if(a[0]>b[0])
        return false;
    else{
        if(a[1]<b[1])
            return true;
        else if(a[1]>b[1])
            return false;
        else
            return a[2]
		}
}

class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        sort(num.begin(), num.end());
        vector<int> tmp;
        for(int i =0,cnt=0; i<num.size(); i++){
            if(i>=2 && num[i]==num[i-1]==num[i-2])
                continue;
            tmp.push_back(num[i]);
        }
        
        threeSum(tmp, tmp.size()-1);
        return r;
    }
    
    set<tuple> r;
    void threeSum(vector<int> &num, int n){
        if(n<2 || num[n]<0)
            return;
        unordered_set<int> hash;
        for(int i =0; i<=n; i++){
            if((i>0 && num[i]==num[i-1]) || (hash.find(num[i]))!=hash.end())
                continue;
            vector<int>::iterator it = lower_bound(num.begin(), num.begin()+n+1, -(num[n]+num[i]));
            if(it!=num.end()){
                hash.insert(*it);
                if(*it>num[i])
                    r.push_back(vector<int>{num[i],*it,num[n]});
                else
                    r.push_back(vector<int>{*it,num[i],num[n]});
            }
        }
        while(n>=2 && num[n-1]==num[n]){
            n--;
        }
        threeSum(num,n-1);
    }
};