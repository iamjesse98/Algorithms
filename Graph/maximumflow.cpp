#include <iostream>#include <fstream>#include <cstdio>#include <cstdlib>#include <ctime>#include <queue>#include <vector>#include <map>#include <list>#include <algorithm>#include <set>#include <cassert>#include <unordered_set>#include <functional>#include <cassert>using namespace std;#define INF numeric_limits<int>::max()class MF{public:    int n,m,s,t;    vector<vector<int> > f,c;    vector<list<int> > adj;    void Init(int numV, int source, int sink){	s = source;	t = sink;	n = numV;	m = 0;	f.assign(n, vector<int>(n,0));	c.assign(n, vector<int>(n,0));	adj.resize(n);    }        void AddEdge(int u, int v, int cap){	adj[u].push_back(v);	c[u][v]=cap;	m++;    }    void ReadFromFile(string filename, int offset=0){	ifstream fin(filename);	int V,E;	fin >> V >> E >> s >> t;	Init(V,s,t);	for(int i=0; i<E; i++){	    int from, to, capacity;	    fin >> from >> to >> capacity;	    AddEdge(from-offset, to-offset, capacity);	}	fin.close();    }};class EdmondsKarp : public MF{public:    int MaximumFlow(){	for(int i=0; i<n; i++){	    for(auto j : adj[i]){		if(c[j][i]==0)		    adj[j].push_back(i);	    }	}	vector<int> parent(n);	vector<bool> visited(n,false);	bool found = true;	while(found){	    queue<int> open;	    visited.assign(n,false);	    visited[s]=true;	    parent[s]=-1;	    open.push(s);	    found = false;	    while(!open.empty()){		int u = open.front();		open.pop();		for(auto v: adj[u]){		    if(visited[v] || c[u][v]<=0)			continue;		    parent[v]=u;		    visited[v]=true;		    if(v==t){			found=true;			break;		    }		    open.push(v);		}	    }	    if(found){		int curr= t;		int delta = INF;		while(curr!=s){		    delta = min(delta, c[parent[curr]][curr]);		    curr = parent[curr];		}		curr = t;		while(curr!=s){		    c[parent[curr]][curr]-=delta;		    c[curr][parent[curr]]+=delta;		    f[parent[curr]][curr]+=delta;		    curr = parent[curr];		}	    }	}	int ret = 0;	for(auto v : adj[s])	    ret+=f[s][v];	return ret;    }};class PushRelabel : public MF{public:    vector<int> e,h;    vector<vector<int> > cf;    void Push(int u,int v){	int delta = min(e[u], cf[u][v]);	f[u][v] += delta;	f[v][u] = -f[u][v];	e[u] -= delta;	e[v] += delta;	cf[u][v] = c[u][v]-f[u][v];	cf[v][u] = c[v][u]-f[v][u];    }    int MaximumFlow(){	cf.assign(n,vector<int>(n,0));	e.assign(n,0);	h.assign(n,0);	cf = c;	h[s] = n;	for(int i=0; i<n; i++){	    for(auto j : adj[i]){		if(c[j][i]==0)		    adj[j].push_back(i);	    }	}	for(auto v : adj[s]){	    f[s][v] = c[s][v];	    f[v][s] = -c[s][v];	    e[v] = c[s][v];	    e[s] -= c[s][v];	    cf[s][v] = c[s][v]-f[s][v];	    cf[v][s] = c[v][s]-f[v][s];	}	queue<int> q;	vector<bool> isOverflow(n, false);		for(auto v: adj[s]){	    if(v!=t){		q.push(v);		isOverflow[v]=true;	    }	}	while(!q.empty()){	    int u = q.front();	    int minHeight = -1;	    for(auto v : adj[u]){		if(e[u]<=0)		    break;		if(cf[u][v]>0){		    if(h[u]>h[v]){			Push(u,v);			if(e[v]>0 && !isOverflow[v] && v!=s && v!=t){			    isOverflow[v]=true;			    q.push(v);			}		    }		    else{			minHeight = minHeight == -1 ? h[v] : min(h[v], minHeight);		    }		}	    }	    if(e[u]>0)		h[u] = minHeight + 1; // Relabel	    else{		isOverflow[u] = false;		q.pop();	    }	}	return e[t];    }};int main(int argc, char** argv){    EdmondsKarp edm;    PushRelabel pr;    cout << argv[1] <<endl;    pr.ReadFromFile(argv[1],1);    edm.ReadFromFile(argv[1],1);    cout << "End reading file" <<endl;    cout << edm.MaximumFlow() << endl;    cout << pr.MaximumFlow() << endl;}